#!/usr/bin/env python3
"""
Sonolbot Telegram I/O helpers.

Key design:
- Receive path always enforces allowed-user filtering.
- 24h context is generated by a separate function (not coupled to receive).
- Outbound text is sent without rewriting or formatting.
- Every send/receive event is logged to logs/YYYY-MM-DD.log.
- Logs are retained for 7 days; older logs are removed automatically.
"""

from __future__ import annotations

import json
import os
import random
import re
import socket
import sys
import time
import errno
from contextlib import contextmanager
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any

import requests

try:
    import fcntl  # type: ignore
except Exception:
    fcntl = None  # type: ignore

try:
    import msvcrt  # type: ignore
except Exception:
    msvcrt = None  # type: ignore


MAX_TELEGRAM_TEXT_LEN = 4096
MAX_TELEGRAM_FILE_BYTES = 50 * 1024 * 1024
LOG_RETENTION_DAYS = 7
MESSAGE_RETENTION_DAYS = 7
DEFAULT_REQUEST_MAX_ATTEMPTS = 4
DEFAULT_REQUEST_RETRY_DELAY_SEC = 1.0
DEFAULT_REQUEST_RETRY_BACKOFF = 1.8
DEFAULT_REQUEST_RETRY_JITTER_SEC = 0.2
DEFAULT_SEND_DEDUPE_WINDOW_SEC = 180.0
DEFAULT_SEND_TEXT_MAX_ATTEMPTS = 4
DEFAULT_SEND_TEXT_RETRY_DELAY_SEC = 0.5
DEFAULT_SEND_TEXT_RETRY_BACKOFF = 2.0
DEFAULT_SEND_TEXT_RETRY_JITTER_SEC = 0.2
REDACTED_VALUE = "***REDACTED***"
SECURE_FILE_MODE = 0o600
SECURE_DIR_MODE = 0o700
TELEGRAM_API_DOMAIN = "api.telegram.org"
TELEGRAM_API_FALLBACK_IPS = [
    "149.154.167.220",
    "149.154.167.197",
    "149.154.167.198",
]
DOH_TIMEOUT_SEC = 5.0

_SENSITIVE_KEY_RE = re.compile(
    r"(?i)(token|password|passwd|pwd|secret|api[_-]?key|access[_-]?key|private[_-]?key)"
)
_SENSITIVE_ASSIGNMENT_RE = re.compile(
    r"(?i)\b((?:api[_-]?key|access[_-]?token|refresh[_-]?token|token|password|passwd|pwd|secret|private[_-]?key)\b\s*[:=]\s*)(\"[^\"]*\"|'[^']*'|[^\s,;]+)"
)
_SENSITIVE_QUERY_PARAM_RE = re.compile(
    r"(?i)([?&](?:token|access_token|refresh_token|api_key|apikey|password|passwd|pwd|secret)=)([^&\s]+)"
)
_AUTH_BEARER_RE = re.compile(r"(?i)(authorization\s*:\s*bearer\s+)([A-Za-z0-9\-._~+/]+=*)")
_TELEGRAM_BOT_TOKEN_RE = re.compile(r"\b\d{7,12}:[A-Za-z0-9_-]{20,}\b")
_OPENAI_KEY_RE = re.compile(r"\bsk-[A-Za-z0-9]{20,}\b")
_GITHUB_TOKEN_RE = re.compile(r"\bgh[pousr]_[A-Za-z0-9]{36,}\b")
_AWS_ACCESS_KEY_RE = re.compile(r"\bAKIA[0-9A-Z]{16}\b")
_SLACK_TOKEN_RE = re.compile(r"\bxox[baprs]-[A-Za-z0-9-]{10,}\b")

_HTTP_SESSION: requests.Session | None = None
_RECENT_SEND_KEYS: dict[str, float] = {}


def _resolve_via_doh_google(domain: str) -> str | None:
    """Resolve domain to IP using Google DNS-over-HTTPS."""
    try:
        url = f"https://dns.google/resolve?name={domain}&type=A"
        resp = requests.get(url, timeout=DOH_TIMEOUT_SEC)
        if resp.status_code != 200:
            return None
        data = resp.json()
        answers = data.get("Answer", [])
        for answer in answers:
            if answer.get("type") == 1:
                ip = answer.get("data")
                if ip and isinstance(ip, str):
                    return ip.strip()
    except Exception:
        pass
    return None


def _resolve_via_doh_cloudflare(domain: str) -> str | None:
    """Resolve domain to IP using Cloudflare DNS-over-HTTPS."""
    try:
        url = f"https://cloudflare-dns.com/dns-query?name={domain}&type=A"
        headers = {"Accept": "application/dns-json"}
        resp = requests.get(url, headers=headers, timeout=DOH_TIMEOUT_SEC)
        if resp.status_code != 200:
            return None
        data = resp.json()
        answers = data.get("Answer", [])
        for answer in answers:
            if answer.get("type") == 1:
                ip = answer.get("data")
                if ip and isinstance(ip, str):
                    return ip.strip()
    except Exception:
        pass
    return None


def _test_telegram_host(host: str, token: str, timeout_sec: float) -> bool:
    """Test if a Telegram API host is reachable."""
    try:
        url = f"https://{host}/bot{token}/getMe"
        resp = requests.get(url, timeout=timeout_sec)
        if resp.status_code == 200:
            data = resp.json()
            return data.get("ok", False)
    except Exception:
        pass
    return False


def _update_env_file(work_dir: Path, key: str, value: str) -> bool:
    """Update or add a key-value pair in .env file."""
    env_path = work_dir / ".env"
    lines: list[str] = []

    if env_path.exists():
        try:
            lines = env_path.read_text(encoding="utf-8").splitlines()
        except Exception:
            return False

    key_pattern = re.compile(f"^{re.escape(key)}\\s*=")
    updated = False
    new_lines = []

    for line in lines:
        if key_pattern.match(line):
            new_lines.append(f"{key}={value}")
            updated = True
        else:
            new_lines.append(line)

    if not updated:
        new_lines.append(f"{key}={value}")

    try:
        temp_path = env_path.with_suffix(".env.tmp")
        temp_path.write_text("\n".join(new_lines) + "\n", encoding="utf-8")
        temp_path.replace(env_path)
        _ensure_private_file(env_path)
        return True
    except Exception:
        try:
            if temp_path.exists():
                temp_path.unlink()
        except Exception:
            pass
        return False


def _determine_telegram_api_host(
    work_dir: Path,
    token: str,
    timeout_sec: float,
    log_callback: Any = None,
) -> str:
    """
    Determine the best Telegram API host to use.

    Strategy:
    1. Check TELEGRAM_API_HOST env var
    2. Try default domain (api.telegram.org)
    3. Try Google DoH
    4. Try Cloudflare DoH
    5. Try fallback IPs

    If DoH succeeds, save to .env for future use.
    """
    def log(event: str, details: dict[str, Any]) -> None:
        if log_callback:
            log_callback(event, details)

    env_host = os.getenv("TELEGRAM_API_HOST", "").strip()
    if env_host:
        log("telegram_host_decision", {"source": "env_var", "host": env_host})
        return env_host

    if _test_telegram_host(TELEGRAM_API_DOMAIN, token, timeout_sec):
        log("telegram_host_decision", {"source": "default_domain", "host": TELEGRAM_API_DOMAIN})
        return TELEGRAM_API_DOMAIN

    log("telegram_host_decision", {"event": "default_domain_failed", "trying": "doh"})

    doh_ip = _resolve_via_doh_google(TELEGRAM_API_DOMAIN)
    if doh_ip and _test_telegram_host(doh_ip, token, timeout_sec):
        log("telegram_host_decision", {"source": "google_doh", "host": doh_ip})
        if _update_env_file(work_dir, "TELEGRAM_API_HOST", doh_ip):
            log("telegram_host_decision", {"event": "env_updated", "key": "TELEGRAM_API_HOST", "value": doh_ip})
        return doh_ip

    doh_ip = _resolve_via_doh_cloudflare(TELEGRAM_API_DOMAIN)
    if doh_ip and _test_telegram_host(doh_ip, token, timeout_sec):
        log("telegram_host_decision", {"source": "cloudflare_doh", "host": doh_ip})
        if _update_env_file(work_dir, "TELEGRAM_API_HOST", doh_ip):
            log("telegram_host_decision", {"event": "env_updated", "key": "TELEGRAM_API_HOST", "value": doh_ip})
        return doh_ip

    log("telegram_host_decision", {"event": "doh_failed", "trying": "fallback_ips"})

    for fallback_ip in TELEGRAM_API_FALLBACK_IPS:
        if _test_telegram_host(fallback_ip, token, timeout_sec):
            log("telegram_host_decision", {"source": "fallback_ip", "host": fallback_ip})
            if _update_env_file(work_dir, "TELEGRAM_API_HOST", fallback_ip):
                log("telegram_host_decision", {"event": "env_updated", "key": "TELEGRAM_API_HOST", "value": fallback_ip})
            return fallback_ip

    log("telegram_host_decision", {"source": "final_fallback", "host": TELEGRAM_API_DOMAIN})
    return TELEGRAM_API_DOMAIN


def build_runtime_vars(ai_vars: dict[str, Any]) -> dict[str, Any]:
    """Build and validate runtime variables supplied by AI/app layer."""
    token = str(ai_vars.get("telegram_bot_token", "")).strip()
    if not token:
        raise ValueError("telegram_bot_token is required")

    allowed_users = _parse_allowed_users(ai_vars.get("telegram_allowed_users"))
    if not allowed_users:
        raise ValueError("telegram_allowed_users is required and must not be empty")

    work_dir = Path(ai_vars.get("work_dir") or os.getcwd()).resolve()
    tasks_dir = Path(ai_vars.get("tasks_dir") or (work_dir / "tasks")).resolve()
    logs_dir = Path(ai_vars.get("logs_dir") or (work_dir / "logs")).resolve()
    api_timeout_sec = float(ai_vars.get("api_timeout_sec", 20.0))
    polling_timeout_sec = int(ai_vars.get("polling_timeout_sec", 5))
    message_retention_days = max(1, int(ai_vars.get("message_retention_days", MESSAGE_RETENTION_DAYS)))
    max_file_bytes = max(1, int(ai_vars.get("max_telegram_file_bytes", MAX_TELEGRAM_FILE_BYTES)))

    logs_dir.mkdir(parents=True, exist_ok=True)
    _ensure_private_dir(logs_dir)

    host_decision_log: list[dict[str, Any]] = []

    def log_host_decision(event: str, details: dict[str, Any]) -> None:
        host_decision_log.append({"event": event, "details": details})

    api_host = _determine_telegram_api_host(
        work_dir=work_dir,
        token=token,
        timeout_sec=min(api_timeout_sec, 10.0),
        log_callback=log_host_decision,
    )

    for log_entry in host_decision_log:
        _write_log_direct(
            logs_dir=logs_dir,
            direction="system",
            event=log_entry["event"],
            details=log_entry["details"],
        )

    return {
        "telegram_bot_token": token,
        "allowed_user_ids": allowed_users,
        "telegram_user_id": ai_vars.get("telegram_user_id"),
        "telegram_include_24h_context": bool(ai_vars.get("telegram_include_24h_context", True)),
        "work_dir": str(work_dir),
        "tasks_dir": str(tasks_dir),
        "logs_dir": str(logs_dir),
        "api_timeout_sec": api_timeout_sec,
        "polling_timeout_sec": polling_timeout_sec,
        "message_retention_days": message_retention_days,
        "max_telegram_file_bytes": max_file_bytes,
        "api_host": api_host,
        "api_base": f"https://{api_host}/bot{token}",
        "file_base": f"https://{api_host}/file/bot{token}",
    }


def _message_store_key(msg: dict[str, Any]) -> str:
    chat_id = msg.get("chat_id")
    message_id = msg.get("message_id")
    msg_type = str(msg.get("type") or "user")
    return f"{msg_type}:{chat_id}:{message_id}"


def _load_message_store_unlocked(path: Path) -> dict[str, Any]:
    if not path.exists():
        return {"messages": [], "last_update_id": 0}
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return {"messages": [], "last_update_id": 0}


def _save_message_store_unlocked(path: Path, data: dict[str, Any]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    _ensure_private_dir(path.parent)
    sanitized = _redact_sensitive_payload(data)
    payload = json.dumps(sanitized, ensure_ascii=False, indent=2)
    tmp = path.with_name(f".{path.name}.tmp.{os.getpid()}.{time.time_ns()}")
    try:
        tmp.write_text(payload, encoding="utf-8")
        _ensure_private_file(tmp)
        os.replace(tmp, path)
        _ensure_private_file(path)
    finally:
        if tmp.exists():
            try:
                tmp.unlink()
            except OSError:
                pass


@contextmanager
def _message_store_lock(path: Path):
    lock_path = path.with_name(f"{path.name}.lock")
    lock_path.parent.mkdir(parents=True, exist_ok=True)
    _ensure_private_dir(lock_path.parent)
    fd = os.open(str(lock_path), os.O_RDWR | os.O_CREAT, SECURE_FILE_MODE)
    lock_acquired = False
    try:
        if fcntl is not None:
            while True:
                try:
                    fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
                    lock_acquired = True
                    break
                except OSError as exc:
                    if exc.errno not in (errno.EACCES, errno.EAGAIN):
                        raise
                    time.sleep(0.05)
        elif msvcrt is not None:
            while True:
                try:
                    os.lseek(fd, 0, os.SEEK_SET)
                    msvcrt.locking(fd, msvcrt.LK_NBLCK, 1)
                    lock_acquired = True
                    break
                except OSError:
                    time.sleep(0.05)
        else:
            lock_acquired = True
        yield
    finally:
        try:
            if lock_acquired:
                if fcntl is not None:
                    fcntl.flock(fd, fcntl.LOCK_UN)
                elif msvcrt is not None:
                    os.lseek(fd, 0, os.SEEK_SET)
                    msvcrt.locking(fd, msvcrt.LK_UNLCK, 1)
        except OSError:
            pass
        try:
            os.close(fd)
        except OSError:
            pass


def load_message_store(store_path: str) -> dict[str, Any]:
    """Load message store from disk."""
    return _load_message_store_unlocked(Path(store_path))


def save_message_store(store_path: str, data: dict[str, Any]) -> None:
    """Save message store to disk."""
    p = Path(store_path)
    with _message_store_lock(p):
        _save_message_store_unlocked(p, data)


def append_messages_to_store(
    store_path: str,
    new_messages: list[dict[str, Any]],
    new_last_update_id: int | None,
) -> dict[str, Any]:
    """Append new messages and update last_update_id."""
    p = Path(store_path)
    with _message_store_lock(p):
        data = _load_message_store_unlocked(p)
        data.setdefault("messages", [])
        data.setdefault("last_update_id", 0)
        changed = False

        if new_messages:
            existing_keys = {_message_store_key(msg) for msg in data.get("messages", [])}
            to_append: list[dict[str, Any]] = []
            for msg in new_messages:
                dedupe_key = _message_store_key(msg)
                if dedupe_key in existing_keys:
                    continue
                existing_keys.add(dedupe_key)
                to_append.append(msg)
            if to_append:
                data["messages"].extend(to_append)
                changed = True

        if new_last_update_id is not None and new_last_update_id > int(data["last_update_id"]):
            data["last_update_id"] = int(new_last_update_id)
            changed = True

        if changed:
            _save_message_store_unlocked(p, data)
        return data


def get_pending_messages(store_path: str, include_bot: bool = False) -> list[dict[str, Any]]:
    """Return unprocessed messages from store."""
    data = load_message_store(store_path)
    messages = data.get("messages", [])
    out = []
    for msg in messages:
        if msg.get("processed", False):
            continue
        if not include_bot and msg.get("type", "user") != "user":
            continue
        out.append(msg)
    return out


def mark_messages_processed(store_path: str, message_ids: list[int] | int) -> int:
    """Mark one or many message ids as processed. Returns count of updated rows."""
    if isinstance(message_ids, int):
        targets = {int(message_ids)}
    else:
        targets = {int(mid) for mid in message_ids}

    p = Path(store_path)
    with _message_store_lock(p):
        data = _load_message_store_unlocked(p)
        messages = data.get("messages", [])
        changed = 0
        for msg in messages:
            mid = msg.get("message_id")
            if isinstance(mid, int) and mid in targets and not msg.get("processed", False):
                msg["processed"] = True
                changed += 1
        if changed:
            _save_message_store_unlocked(p, data)
        return changed


def save_bot_response(
    store_path: str,
    chat_id: int,
    text: str,
    reply_to_message_ids: list[int] | int,
    files: list[str] | None = None,
) -> None:
    """Append bot response entry to message store for context continuity."""
    if isinstance(reply_to_message_ids, int):
        reply_ids = [int(reply_to_message_ids)]
    else:
        reply_ids = [int(mid) for mid in reply_to_message_ids]

    p = Path(store_path)
    with _message_store_lock(p):
        data = _load_message_store_unlocked(p)
        data.setdefault("messages", [])
        entry = {
            "message_id": f"bot_{reply_ids[0]}_{datetime.now().strftime('%Y%m%d%H%M%S')}",
            "type": "bot",
            "chat_id": int(chat_id),
            "text": text or "",
            "files": files or [],
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "reply_to": reply_ids,
            "processed": True,
        }
        data["messages"].append(entry)
        _save_message_store_unlocked(p, data)


def poll_store_and_get_pending(
    runtime: dict[str, Any],
    store_path: str,
    include_bot: bool = False,
) -> tuple[list[dict[str, Any]], list[dict[str, Any]], int]:
    """
    Poll Telegram once, append to store, and return:
    - new_messages
    - pending_messages
    - last_update_id
    """
    p = Path(store_path)
    with _message_store_lock(p):
        current = _load_message_store_unlocked(p)
        last_update_id = int(current.get("last_update_id", 0))

    new_messages, new_last_update_id = receive_once(runtime, last_update_id=last_update_id)

    removed_count = 0
    appended_messages: list[dict[str, Any]] = []
    with _message_store_lock(p):
        updated = _load_message_store_unlocked(p)
        updated.setdefault("messages", [])
        updated.setdefault("last_update_id", 0)
        existing_keys = {_message_store_key(msg) for msg in updated.get("messages", [])}

        for msg in new_messages:
            dedupe_key = _message_store_key(msg)
            if dedupe_key in existing_keys:
                continue
            existing_keys.add(dedupe_key)
            updated["messages"].append(msg)
            appended_messages.append(msg)

        changed = bool(appended_messages)
        if new_last_update_id is not None and new_last_update_id > int(updated["last_update_id"]):
            updated["last_update_id"] = int(new_last_update_id)
            changed = True

        removed_count = _prune_message_store_data(
            updated,
            retention_days=int(runtime.get("message_retention_days", MESSAGE_RETENTION_DAYS)),
        )
        if removed_count > 0:
            changed = True

        if changed:
            _save_message_store_unlocked(p, updated)

        pending = []
        for msg in updated.get("messages", []):
            if msg.get("processed", False):
                continue
            if not include_bot and msg.get("type", "user") != "user":
                continue
            pending.append(msg)
        last_seen_update = int(updated.get("last_update_id", new_last_update_id))

    if removed_count > 0:
        _write_log(
            runtime,
            direction="system",
            event="message_store_pruned",
            details={
                "store_path": str(store_path),
                "retention_days": int(runtime.get("message_retention_days", MESSAGE_RETENTION_DAYS)),
                "removed_count": removed_count,
                "remaining_count": len(updated.get("messages", [])),
            },
        )
    return appended_messages, pending, last_seen_update


def receive_once(runtime: dict[str, Any], last_update_id: int = 0) -> tuple[list[dict[str, Any]], int]:
    """
    Poll Telegram once and return accepted messages.

    Supports:
    - text
    - photo
    - document
    - video
    - audio
    - voice
    - location
    """
    payload = {
        "offset": int(last_update_id) + 1,
        "timeout": int(runtime["polling_timeout_sec"]),
        "allowed_updates": ["message", "callback_query"],
    }
    resp = _telegram_request(runtime, "getUpdates", payload=payload)
    if not resp:
        return [], int(last_update_id)

    updates = resp.get("result", [])
    accepted_messages: list[dict[str, Any]] = []
    new_last_update_id = int(last_update_id)

    for update in updates:
        update_id = int(update.get("update_id", 0))
        if update_id > new_last_update_id:
            new_last_update_id = update_id

        callback = update.get("callback_query")
        if isinstance(callback, dict):
            callback_user = callback.get("from", {}) or {}
            callback_user_id = int(callback_user.get("id", 0))
            if callback_user_id not in runtime["allowed_user_ids"]:
                _write_log(
                    runtime,
                    direction="receive",
                    event="blocked_callback_user",
                    details={"user_id": callback_user_id, "update_id": update_id},
                )
                continue

            callback_message = callback.get("message") if isinstance(callback.get("message"), dict) else {}
            callback_chat = callback_message.get("chat", {}) if isinstance(callback_message.get("chat"), dict) else {}
            callback_chat_id = callback_chat.get("id")
            callback_data = str(callback.get("data") or "").strip()
            callback_query_id = str(callback.get("id") or "").strip()

            if callback_chat_id is None or not callback_data:
                if callback_query_id:
                    _telegram_request(
                        runtime,
                        "answerCallbackQuery",
                        payload={"callback_query_id": callback_query_id},
                    )
                continue

            callback_text = f"__cb__:{callback_data}"
            callback_timestamp = _format_message_timestamp(
                callback_message.get("date") if isinstance(callback_message, dict) else None
            )
            callback_message_data = {
                "message_id": update_id,
                "update_id": update_id,
                "type": "user",
                "user_id": callback_user_id,
                "username": callback_user.get("username") or "",
                "first_name": callback_user.get("first_name") or "",
                "last_name": callback_user.get("last_name") or "",
                "chat_id": callback_chat_id,
                "text": callback_text,
                "files": [],
                "location": None,
                "timestamp": callback_timestamp,
                "processed": False,
                "callback_message_id": int(callback_message.get("message_id", 0) or 0),
            }
            accepted_messages.append(callback_message_data)
            if callback_query_id:
                _telegram_request(
                    runtime,
                    "answerCallbackQuery",
                    payload={"callback_query_id": callback_query_id},
                )
            _write_log(
                runtime,
                direction="receive",
                event="accepted_callback",
                details={
                    "message_id": update_id,
                    "chat_id": callback_chat_id,
                    "callback_data": callback_data,
                },
            )
            continue

        msg = update.get("message")
        if not isinstance(msg, dict):
            continue

        user = msg.get("from", {}) or {}
        user_id = int(user.get("id", 0))
        if user_id not in runtime["allowed_user_ids"]:
            _write_log(
                runtime,
                direction="receive",
                event="blocked_user",
                details={"user_id": user_id, "message_id": msg.get("message_id")},
            )
            continue

        message_id = msg.get("message_id")
        if message_id is None:
            continue
        message_id = int(message_id)

        chat = msg.get("chat", {}) or {}
        chat_id = chat.get("id")
        text = (msg.get("caption") or msg.get("text") or "")

        files: list[dict[str, Any]] = []

        photos = msg.get("photo") or []
        if photos:
            largest = photos[-1]
            file_id = largest.get("file_id")
            if file_id:
                downloaded = _download_file(
                    runtime=runtime,
                    file_id=file_id,
                    message_id=message_id,
                    file_type="photo",
                    preferred_name=None,
                )
                if downloaded:
                    downloaded["size"] = largest.get("file_size", downloaded.get("size", 0))
                    files.append(downloaded)

        document = msg.get("document")
        if isinstance(document, dict) and document.get("file_id"):
            downloaded = _download_file(
                runtime=runtime,
                file_id=document["file_id"],
                message_id=message_id,
                file_type="document",
                preferred_name=document.get("file_name"),
            )
            if downloaded:
                downloaded["name"] = document.get("file_name")
                downloaded["mime_type"] = document.get("mime_type")
                downloaded["size"] = document.get("file_size", downloaded.get("size", 0))
                files.append(downloaded)

        video = msg.get("video")
        if isinstance(video, dict) and video.get("file_id"):
            downloaded = _download_file(
                runtime=runtime,
                file_id=video["file_id"],
                message_id=message_id,
                file_type="video",
                preferred_name=None,
            )
            if downloaded:
                downloaded["duration"] = video.get("duration")
                downloaded["size"] = video.get("file_size", downloaded.get("size", 0))
                files.append(downloaded)

        audio = msg.get("audio")
        if isinstance(audio, dict) and audio.get("file_id"):
            downloaded = _download_file(
                runtime=runtime,
                file_id=audio["file_id"],
                message_id=message_id,
                file_type="audio",
                preferred_name=audio.get("file_name"),
            )
            if downloaded:
                downloaded["duration"] = audio.get("duration")
                downloaded["size"] = audio.get("file_size", downloaded.get("size", 0))
                files.append(downloaded)

        voice = msg.get("voice")
        if isinstance(voice, dict) and voice.get("file_id"):
            downloaded = _download_file(
                runtime=runtime,
                file_id=voice["file_id"],
                message_id=message_id,
                file_type="voice",
                preferred_name=None,
            )
            if downloaded:
                downloaded["duration"] = voice.get("duration")
                downloaded["size"] = voice.get("file_size", downloaded.get("size", 0))
                files.append(downloaded)

        location_info = None
        location = msg.get("location")
        if isinstance(location, dict):
            lat = location.get("latitude")
            lon = location.get("longitude")
            if lat is not None and lon is not None:
                location_info = {"latitude": lat, "longitude": lon}
                accuracy = location.get("horizontal_accuracy")
                if accuracy is not None:
                    location_info["accuracy"] = accuracy

        if not text and not files and not location_info:
            continue

        timestamp = _format_message_timestamp(msg.get("date"))
        message_data = {
            "message_id": message_id,
            "update_id": update_id,
            "type": "user",
            "user_id": user_id,
            "username": user.get("username") or "",
            "first_name": user.get("first_name") or "",
            "last_name": user.get("last_name") or "",
            "chat_id": chat_id,
            "text": text,
            "files": files,
            "location": location_info,
            "timestamp": timestamp,
            "processed": False,
        }
        accepted_messages.append(message_data)

        _write_log(
            runtime,
            direction="receive",
            event="accepted_message",
            details={
                "message_id": message_id,
                "chat_id": chat_id,
                "has_text": bool(text),
                "file_count": len(files),
                "has_location": bool(location_info),
            },
        )

    return accepted_messages, new_last_update_id


def get_me(
    runtime: dict[str, Any],
    request_max_attempts: int | None = None,
) -> dict[str, Any]:
    """Fetch current bot profile via Telegram getMe."""
    resp = _telegram_request(
        runtime,
        "getMe",
        payload={},
        max_attempts_override=request_max_attempts,
    )
    if not resp:
        _write_log(
            runtime,
            direction="system",
            event="get_me_failed",
            details={},
        )
        return {}
    result = resp.get("result")
    if isinstance(result, dict):
        return result
    return {}


def get_my_name(
    runtime: dict[str, Any],
    language_code: str = "",
    request_max_attempts: int | None = None,
) -> str:
    """Fetch configured bot display name via Telegram getMyName."""
    payload: dict[str, Any] = {}
    normalized_lang = str(language_code or "").strip()
    if normalized_lang:
        payload["language_code"] = normalized_lang
    resp = _telegram_request(
        runtime,
        "getMyName",
        payload=payload,
        max_attempts_override=request_max_attempts,
    )
    if not resp:
        _write_log(
            runtime,
            direction="system",
            event="get_my_name_failed",
            details={"language_code": normalized_lang},
        )
        return ""
    result = resp.get("result")
    if not isinstance(result, dict):
        return ""
    return str(result.get("name") or "").strip()


def set_my_name(
    runtime: dict[str, Any],
    name: str,
    language_code: str = "",
    request_max_attempts: int | None = None,
) -> bool:
    """Set bot display name via Telegram setMyName."""
    normalized_name = str(name or "").strip()
    if not normalized_name:
        return False
    payload: dict[str, Any] = {"name": normalized_name}
    normalized_lang = str(language_code or "").strip()
    if normalized_lang:
        payload["language_code"] = normalized_lang
    resp = _telegram_request(
        runtime,
        "setMyName",
        payload=payload,
        max_attempts_override=request_max_attempts,
    )
    ok = bool(resp)
    _write_log(
        runtime,
        direction="system",
        event="set_my_name_ok" if ok else "set_my_name_failed",
        details={"language_code": normalized_lang, "name_len": len(normalized_name)},
    )
    return ok


def send_text_raw(
    runtime: dict[str, Any],
    chat_id: int,
    text: str,
    request_max_attempts: int | None = None,
    reply_markup: dict[str, Any] | None = None,
    parse_mode: str | None = None,
) -> bool:
    """
    Send text without rewriting or additional formatting.

    If the text exceeds Telegram limits, it is split into contiguous chunks while
    preserving exact content order.
    """
    if text is None:
        text = ""

    chunks = [text[i : i + MAX_TELEGRAM_TEXT_LEN] for i in range(0, len(text), MAX_TELEGRAM_TEXT_LEN)]
    if not chunks:
        chunks = [""]

    for idx, chunk in enumerate(chunks, start=1):
        payload = {"chat_id": int(chat_id), "text": chunk}
        normalized_parse_mode = str(parse_mode or "").strip()
        if normalized_parse_mode:
            payload["parse_mode"] = normalized_parse_mode
        if idx == 1 and isinstance(reply_markup, dict) and reply_markup:
            payload["reply_markup"] = reply_markup
        resp = _telegram_request(
            runtime,
            "sendMessage",
            payload=payload,
            max_attempts_override=request_max_attempts,
        )
        if not resp:
            _write_log(
                runtime,
                direction="send",
                event="send_text_failed",
                details={"chat_id": chat_id, "chunk_index": idx, "chunk_count": len(chunks)},
            )
            return False

        _write_log(
            runtime,
            direction="send",
            event="send_text_ok",
            details={"chat_id": chat_id, "chunk_index": idx, "chunk_count": len(chunks), "length": len(chunk)},
        )

    return True


def send_text_with_keyboard(
    runtime: dict[str, Any],
    chat_id: int,
    text: str,
    keyboard_rows: list[list[str]],
    resize_keyboard: bool = True,
    one_time_keyboard: bool = False,
    request_max_attempts: int | None = None,
    parse_mode: str | None = None,
) -> bool:
    """Send text with Telegram reply keyboard."""
    normalized_rows: list[list[str]] = []
    for row in keyboard_rows or []:
        if not isinstance(row, list):
            continue
        normalized_row = []
        for cell in row:
            value = str(cell or "").strip()
            if value:
                normalized_row.append(value)
        if normalized_row:
            normalized_rows.append(normalized_row)

    reply_markup: dict[str, Any] | None = None
    if normalized_rows:
        reply_markup = {
            "keyboard": normalized_rows,
            "resize_keyboard": bool(resize_keyboard),
            "one_time_keyboard": bool(one_time_keyboard),
        }
    return send_text_raw(
        runtime=runtime,
        chat_id=chat_id,
        text=text,
        request_max_attempts=request_max_attempts,
        reply_markup=reply_markup,
        parse_mode=parse_mode,
    )


def send_text_with_inline_keyboard(
    runtime: dict[str, Any],
    chat_id: int,
    text: str,
    inline_keyboard_rows: list[list[dict[str, Any]]],
    request_max_attempts: int | None = None,
    parse_mode: str | None = None,
) -> bool:
    """Send text with Telegram inline keyboard."""
    normalized_rows: list[list[dict[str, str]]] = []
    for row in inline_keyboard_rows or []:
        if not isinstance(row, list):
            continue
        normalized_row: list[dict[str, str]] = []
        for cell in row:
            if not isinstance(cell, dict):
                continue
            label = str(cell.get("text") or "").strip()
            callback_data = str(cell.get("callback_data") or "").strip()
            url = str(cell.get("url") or "").strip()
            if not label:
                continue
            if callback_data:
                normalized_row.append({"text": label, "callback_data": callback_data[:64]})
                continue
            if url:
                normalized_row.append({"text": label, "url": url})
        if normalized_row:
            normalized_rows.append(normalized_row)

    reply_markup: dict[str, Any] | None = None
    if normalized_rows:
        reply_markup = {"inline_keyboard": normalized_rows}

    return send_text_raw(
        runtime=runtime,
        chat_id=chat_id,
        text=text,
        request_max_attempts=request_max_attempts,
        reply_markup=reply_markup,
        parse_mode=parse_mode,
    )


def edit_message_text(
    runtime: dict[str, Any],
    chat_id: int,
    message_id: int,
    text: str,
    inline_keyboard_rows: list[list[dict[str, Any]]] | None = None,
    request_max_attempts: int | None = None,
    parse_mode: str | None = None,
) -> bool:
    """Edit an existing message text (optionally replacing inline keyboard)."""
    payload: dict[str, Any] = {
        "chat_id": int(chat_id),
        "message_id": int(message_id),
        "text": str(text or ""),
    }
    normalized_parse_mode = str(parse_mode or "").strip()
    if normalized_parse_mode:
        payload["parse_mode"] = normalized_parse_mode

    if inline_keyboard_rows is not None:
        normalized_rows: list[list[dict[str, str]]] = []
        for row in inline_keyboard_rows or []:
            if not isinstance(row, list):
                continue
            normalized_row: list[dict[str, str]] = []
            for cell in row:
                if not isinstance(cell, dict):
                    continue
                label = str(cell.get("text") or "").strip()
                callback_data = str(cell.get("callback_data") or "").strip()
                url = str(cell.get("url") or "").strip()
                if not label:
                    continue
                if callback_data:
                    normalized_row.append({"text": label, "callback_data": callback_data[:64]})
                    continue
                if url:
                    normalized_row.append({"text": label, "url": url})
            if normalized_row:
                normalized_rows.append(normalized_row)
        payload["reply_markup"] = {"inline_keyboard": normalized_rows}

    resp = _telegram_request(
        runtime,
        "editMessageText",
        payload=payload,
        max_attempts_override=request_max_attempts,
    )
    if not resp:
        _write_log(
            runtime,
            direction="send",
            event="edit_message_failed",
            details={"chat_id": int(chat_id), "message_id": int(message_id)},
        )
        return False

    _write_log(
        runtime,
        direction="send",
        event="edit_message_ok",
        details={"chat_id": int(chat_id), "message_id": int(message_id), "length": len(str(text or ""))},
    )
    return True


def send_file_raw(runtime: dict[str, Any], chat_id: int, file_path: str) -> bool:
    """Send one file via sendDocument."""
    p = Path(file_path)
    if not p.exists():
        _write_log(
            runtime,
            direction="send",
            event="send_file_missing",
            details={"chat_id": chat_id, "file_path": str(p)},
        )
        return False

    max_file_bytes = int(runtime.get("max_telegram_file_bytes", MAX_TELEGRAM_FILE_BYTES))
    file_size = p.stat().st_size
    if file_size > max_file_bytes:
        _write_log(
            runtime,
            direction="send",
            event="send_file_too_large",
            details={
                "chat_id": chat_id,
                "file_path": str(p),
                "size_bytes": file_size,
                "max_size_bytes": max_file_bytes,
            },
        )
        return False

    with p.open("rb") as fp:
        files = {"document": (p.name, fp)}
        payload = {"chat_id": int(chat_id)}
        resp = _telegram_request(runtime, "sendDocument", payload=payload, files=files)

    if not resp:
        _write_log(
            runtime,
            direction="send",
            event="send_file_failed",
            details={"chat_id": chat_id, "file_path": str(p)},
        )
        return False

    _write_log(
        runtime,
        direction="send",
        event="send_file_ok",
        details={"chat_id": chat_id, "file_path": str(p), "size_bytes": file_size},
    )
    return True


def send_files_raw(runtime: dict[str, Any], chat_id: int, text: str, file_paths: list[str]) -> bool:
    """Send raw text first, then send files one by one."""
    if not send_text_raw(runtime, chat_id=chat_id, text=text):
        return False

    all_ok = True
    for file_path in file_paths or []:
        ok = send_file_raw(runtime, chat_id=chat_id, file_path=file_path)
        if not ok:
            all_ok = False
    return all_ok


def compose_ack_and_progress_message(
    message_id: int,
    stage: str,
    summary: str = "",
    details: str = "",
) -> str:
    """
    Compose one combined message for ACK + progress.

    This reduces API calls in unstable DNS/network environments.
    """
    stage_text = (stage or "").strip() or "요청 분석 중"
    lines = [
        "새메시지 확인했습니다",
        "[진행상황]",
        f"작업ID: msg_{int(message_id)}",
        f"지금 단계: {stage_text}",
    ]
    summary_text = (summary or "").strip()
    if summary_text:
        lines.append(f"요약: {summary_text}")
    detail_text = (details or "").strip()
    if detail_text:
        lines.append(detail_text)
    return "\n".join(lines)


def send_text_with_policy(
    runtime: dict[str, Any],
    chat_id: int,
    text: str,
    *,
    dedupe_key: str | None = None,
    hold_message_id: int | None = None,
    message_max_attempts: int | None = None,
    request_max_attempts: int | None = None,
) -> bool:
    """
    Send one message with a strict policy:
    - no extra fallback/cause send on failure
    - optional dedupe key to reduce duplicate spam
    """
    now = time.time()
    window_sec = _send_dedupe_window_sec()
    if dedupe_key:
        _cleanup_recent_send_keys(now, window_sec)
        last = _RECENT_SEND_KEYS.get(dedupe_key)
        if isinstance(last, float) and (now - last) <= window_sec:
            _write_log(
                runtime,
                direction="send",
                event="send_text_deduped",
                details={
                    "chat_id": int(chat_id),
                    "dedupe_key": dedupe_key,
                    "window_sec": round(window_sec, 3),
                },
            )
            return True

    ok = send_text_retry(
        runtime,
        chat_id=chat_id,
        text=text,
        message_max_attempts=message_max_attempts,
        request_max_attempts=request_max_attempts,
    )
    if ok:
        if dedupe_key:
            _RECENT_SEND_KEYS[dedupe_key] = now
        return True

    _write_log(
        runtime,
        direction="send",
        event="send_text_held_for_retry_cycle",
        details={
            "chat_id": int(chat_id),
            "hold_message_id": int(hold_message_id) if isinstance(hold_message_id, int) else None,
            "dedupe_key": dedupe_key or "",
            "reason": "send_failed_no_additional_send",
        },
    )
    return False


def send_text_retry(
    runtime: dict[str, Any],
    chat_id: int,
    text: str,
    *,
    message_max_attempts: int | None = None,
    request_max_attempts: int | None = None,
) -> bool:
    """
    Message-level retry wrapper for send_text_raw.

    By default this uses request_max_attempts=1 per message attempt to avoid
    multiplicative retry storms in unstable DNS environments.
    """
    max_attempts = _send_text_max_attempts(message_max_attempts)
    retry_delay_sec = _send_text_retry_delay_sec()
    retry_backoff = _send_text_retry_backoff()
    retry_jitter_sec = _send_text_retry_jitter_sec()

    effective_request_attempts = (
        max(1, int(request_max_attempts))
        if isinstance(request_max_attempts, int)
        else 1
    )

    for attempt in range(1, max_attempts + 1):
        ok = send_text_raw(
            runtime,
            chat_id=chat_id,
            text=text,
            request_max_attempts=effective_request_attempts,
        )
        if ok:
            return True
        if attempt < max_attempts:
            base_sleep_sec = retry_delay_sec * (retry_backoff ** (attempt - 1))
            jitter_sec = random.uniform(0.0, retry_jitter_sec) if retry_jitter_sec > 0 else 0.0
            sleep_sec = base_sleep_sec + jitter_sec
            _write_log(
                runtime,
                direction="send",
                event="send_text_retry",
                details={
                    "chat_id": int(chat_id),
                    "attempt": attempt,
                    "max_attempts": max_attempts,
                    "sleep_sec": round(sleep_sec, 3),
                    "base_sleep_sec": round(base_sleep_sec, 3),
                    "jitter_sec": round(jitter_sec, 3),
                    "request_max_attempts": effective_request_attempts,
                },
            )
            time.sleep(max(0.05, sleep_sec))
    return False


def send_ack_and_progress(
    runtime: dict[str, Any],
    chat_id: int,
    message_id: int,
    stage: str,
    summary: str = "",
    details: str = "",
    message_max_attempts: int | None = None,
    request_max_attempts: int | None = None,
) -> bool:
    """
    Preferred first notification path:
    one message for ACK + progress (instead of two separate sends).
    """
    text = compose_ack_and_progress_message(
        message_id=message_id,
        stage=stage,
        summary=summary,
        details=details,
    )
    dedupe_key = f"ack_progress:msg_{int(message_id)}:{_safe_dedupe_fragment(stage)}"
    return send_text_with_policy(
        runtime,
        chat_id=chat_id,
        text=text,
        dedupe_key=dedupe_key,
        hold_message_id=int(message_id),
        message_max_attempts=message_max_attempts,
        request_max_attempts=request_max_attempts,
    )


def send_final_answer(
    runtime: dict[str, Any],
    chat_id: int,
    message_id: int,
    answer_text: str,
    *,
    include_completion_in_body: bool = True,
    completion_text: str = "",
    message_max_attempts: int | None = None,
    request_max_attempts: int | None = None,
) -> bool:
    """
    Preferred final notification path:
    send one final answer message and optionally append completion marker in-body.
    """
    answer = answer_text or ""
    final_text = answer
    if include_completion_in_body:
        done_line = (completion_text or "").strip() or f"[작업완료] msg_{int(message_id)}"
        if final_text.strip():
            final_text = final_text.rstrip() + "\n\n" + done_line
        else:
            final_text = done_line

    dedupe_key = f"final_answer:msg_{int(message_id)}"
    return send_text_with_policy(
        runtime,
        chat_id=chat_id,
        text=final_text,
        dedupe_key=dedupe_key,
        hold_message_id=int(message_id),
        message_max_attempts=message_max_attempts,
        request_max_attempts=request_max_attempts,
    )


def build_24h_context(messages: list[dict[str, Any]], current_message_id: int | None = None) -> str:
    """
    Build 24-hour conversation context.

    This function is intentionally separate from receive logic.
    """
    now = datetime.now()
    cutoff = now - timedelta(hours=24)

    lines: list[str] = ["=== Last 24h Conversation Context ===", ""]
    appended = 0

    for msg in messages:
        msg_type = msg.get("type", "user")
        if current_message_id is not None and msg_type == "user" and msg.get("message_id") == current_message_id:
            break

        ts = _parse_timestamp(msg.get("timestamp"))
        if ts is None or ts < cutoff:
            continue

        if msg_type == "bot":
            text = msg.get("text", "") or ""
            files = msg.get("files") or []
            file_info = ""
            if files:
                rendered_names = []
                for item in files:
                    if isinstance(item, str):
                        rendered_names.append(item)
                    elif isinstance(item, dict):
                        rendered_names.append(os.path.basename(item.get("path", "")))
                if rendered_names:
                    file_info = f" [sent: {', '.join(rendered_names)}]"
            lines.append(f"[{msg.get('timestamp')}] BOT: {text}{file_info}")
            appended += 1
            continue

        user_name = msg.get("first_name", "User")
        text = msg.get("text", "") or ""
        files = msg.get("files") or []
        location = msg.get("location")

        suffix_parts = []
        if files:
            suffix_parts.append(f"attachments:{len(files)}")
        if isinstance(location, dict):
            lat = location.get("latitude")
            lon = location.get("longitude")
            suffix_parts.append(f"location:{lat},{lon}")
        suffix = f" [{' | '.join(suffix_parts)}]" if suffix_parts else ""

        lines.append(f"[{msg.get('timestamp')}] {user_name}: {text}{suffix}")
        appended += 1

    if appended == 0:
        return "No messages in the last 24 hours."
    return "\n".join(lines)


def _download_file(
    runtime: dict[str, Any],
    file_id: str,
    message_id: int,
    file_type: str,
    preferred_name: str | None,
) -> dict[str, Any] | None:
    file_meta_resp = _telegram_request(runtime, "getFile", payload={"file_id": file_id})
    if not file_meta_resp:
        return None

    info = file_meta_resp.get("result", {})
    remote_file_path = info.get("file_path")
    if not remote_file_path:
        return None
    max_file_bytes = int(runtime.get("max_telegram_file_bytes", MAX_TELEGRAM_FILE_BYTES))
    declared_file_size = int(info.get("file_size") or 0)
    if declared_file_size > max_file_bytes:
        _write_log(
            runtime,
            direction="receive",
            event="file_download_too_large",
            details={
                "file_id": file_id,
                "message_id": message_id,
                "declared_size_bytes": declared_file_size,
                "max_size_bytes": max_file_bytes,
            },
        )
        return None

    task_dir = Path(runtime["tasks_dir"]) / f"msg_{message_id}"
    task_dir.mkdir(parents=True, exist_ok=True)
    _ensure_private_dir(task_dir)

    if preferred_name:
        filename = _safe_filename(preferred_name)
    else:
        filename = _make_default_filename(file_type, message_id, remote_file_path)
    local_path = task_dir / filename

    download_url = f"{runtime['file_base']}/{remote_file_path}"
    written_bytes = 0
    try:
        session = _get_http_session()
        with session.get(download_url, timeout=float(runtime["api_timeout_sec"]), stream=True) as response:
            response.raise_for_status()
            with local_path.open("wb") as f:
                for chunk in response.iter_content(chunk_size=64 * 1024):
                    if not chunk:
                        continue
                    written_bytes += len(chunk)
                    if written_bytes > max_file_bytes:
                        raise ValueError(
                            f"downloaded file exceeds size limit ({written_bytes}>{max_file_bytes})"
                        )
                    f.write(chunk)
        _ensure_private_file(local_path)
    except Exception as exc:
        try:
            if local_path.exists():
                local_path.unlink()
        except OSError:
            pass
        is_size_limit = isinstance(exc, ValueError) and "exceeds size limit" in str(exc)
        _write_log(
            runtime,
            direction="receive",
            event="file_download_too_large" if is_size_limit else "file_download_failed",
            details={
                "file_id": file_id,
                "message_id": message_id,
                "error": str(exc),
                "max_size_bytes": max_file_bytes,
            },
        )
        return None

    file_size = declared_file_size or written_bytes or int(local_path.stat().st_size)
    _write_log(
        runtime,
        direction="receive",
        event="file_download_ok",
        details={
            "message_id": message_id,
            "file_type": file_type,
            "file_path": str(local_path),
            "size_bytes": file_size,
        },
    )

    return {"type": file_type, "path": str(local_path), "size": file_size}


def _telegram_request(
    runtime: dict[str, Any],
    method: str,
    payload: dict[str, Any] | None = None,
    files: dict[str, Any] | None = None,
    max_attempts_override: int | None = None,
) -> dict[str, Any] | None:
    url = f"{runtime['api_base']}/{method}"
    timeout = float(runtime["api_timeout_sec"])
    max_attempts = _request_max_attempts(max_attempts_override)
    retry_delay_sec = _request_retry_delay_sec()
    retry_backoff = _request_retry_backoff()
    retry_jitter_sec = _request_retry_jitter_sec()
    session = _get_http_session()

    for attempt in range(1, max_attempts + 1):
        try:
            if files:
                resp = session.post(url, data=payload or {}, files=files, timeout=timeout)
            else:
                resp = session.post(url, json=payload or {}, timeout=timeout)
        except Exception as exc:
            if attempt < max_attempts:
                base_sleep_sec = retry_delay_sec * (retry_backoff ** (attempt - 1))
                jitter_sec = random.uniform(0.0, retry_jitter_sec) if retry_jitter_sec > 0 else 0.0
                sleep_sec = base_sleep_sec + jitter_sec
                _write_log(
                    runtime,
                    direction="system",
                    event="request_error_retry",
                    details={
                        "method": method,
                        "attempt": attempt,
                        "max_attempts": max_attempts,
                        "sleep_sec": round(sleep_sec, 3),
                        "base_sleep_sec": round(base_sleep_sec, 3),
                        "jitter_sec": round(jitter_sec, 3),
                        "error_type": type(exc).__name__,
                        "error": str(exc),
                    },
                )
                time.sleep(max(0.05, sleep_sec))
                continue

            network_diag = _collect_network_diagnostics()
            runtime["_telegram_last_error"] = {
                "kind": "network",
                "method": method,
                "error_type": type(exc).__name__,
                "error": str(exc),
                "attempt": attempt,
                "max_attempts": max_attempts,
            }
            _write_log(
                runtime,
                direction="system",
                event="request_error",
                details={
                    "method": method,
                    "error_type": type(exc).__name__,
                    "error": str(exc),
                    "network_diag": network_diag,
                    "attempt": attempt,
                    "max_attempts": max_attempts,
                },
            )
            return None

        if resp.status_code != 200:
            runtime["_telegram_last_error"] = {
                "kind": "http",
                "method": method,
                "status_code": int(resp.status_code),
                "body": str(resp.text or "")[:2000],
            }
            _write_log(
                runtime,
                direction="system",
                event="http_error",
                details={"method": method, "status_code": resp.status_code, "body": resp.text[:2000]},
            )
            return None

        try:
            data = resp.json()
        except Exception as exc:
            runtime["_telegram_last_error"] = {
                "kind": "invalid_json",
                "method": method,
                "error_type": type(exc).__name__,
                "error": str(exc),
                "body": str(resp.text or "")[:2000],
            }
            _write_log(
                runtime,
                direction="system",
                event="invalid_json",
                details={"method": method, "error": str(exc), "body": resp.text[:2000]},
            )
            return None

        if not data.get("ok", False):
            runtime["_telegram_last_error"] = {
                "kind": "api_error",
                "method": method,
                "response": data,
            }
            _write_log(
                runtime,
                direction="system",
                event="telegram_api_error",
                details={"method": method, "response": data},
            )
            return None

        runtime["_telegram_last_error"] = None
        return data
    return None


def _request_max_attempts(override: int | None) -> int:
    if isinstance(override, int):
        return max(1, override)
    raw = (os.getenv("TELEGRAM_REQUEST_MAX_ATTEMPTS", "") or "").strip()
    if not raw:
        return DEFAULT_REQUEST_MAX_ATTEMPTS
    try:
        return max(1, int(raw))
    except ValueError:
        return DEFAULT_REQUEST_MAX_ATTEMPTS


def _request_retry_delay_sec() -> float:
    raw = (os.getenv("TELEGRAM_REQUEST_RETRY_DELAY_SEC", "") or "").strip()
    if not raw:
        return DEFAULT_REQUEST_RETRY_DELAY_SEC
    try:
        return max(0.05, float(raw))
    except ValueError:
        return DEFAULT_REQUEST_RETRY_DELAY_SEC


def _request_retry_backoff() -> float:
    raw = (os.getenv("TELEGRAM_REQUEST_RETRY_BACKOFF", "") or "").strip()
    if not raw:
        return DEFAULT_REQUEST_RETRY_BACKOFF
    try:
        return max(1.0, float(raw))
    except ValueError:
        return DEFAULT_REQUEST_RETRY_BACKOFF


def _request_retry_jitter_sec() -> float:
    raw = (os.getenv("TELEGRAM_REQUEST_RETRY_JITTER_SEC", "") or "").strip()
    if not raw:
        return DEFAULT_REQUEST_RETRY_JITTER_SEC
    try:
        return max(0.0, float(raw))
    except ValueError:
        return DEFAULT_REQUEST_RETRY_JITTER_SEC


def _send_text_max_attempts(override: int | None) -> int:
    if isinstance(override, int):
        return max(1, override)
    raw = (os.getenv("TELEGRAM_SEND_MAX_ATTEMPTS", "") or "").strip()
    if not raw:
        return DEFAULT_SEND_TEXT_MAX_ATTEMPTS
    try:
        return max(1, int(raw))
    except ValueError:
        return DEFAULT_SEND_TEXT_MAX_ATTEMPTS


def _send_text_retry_delay_sec() -> float:
    raw = (os.getenv("TELEGRAM_SEND_RETRY_DELAY_SEC", "") or "").strip()
    if not raw:
        return DEFAULT_SEND_TEXT_RETRY_DELAY_SEC
    try:
        return max(0.05, float(raw))
    except ValueError:
        return DEFAULT_SEND_TEXT_RETRY_DELAY_SEC


def _send_text_retry_backoff() -> float:
    raw = (os.getenv("TELEGRAM_SEND_RETRY_BACKOFF", "") or "").strip()
    if not raw:
        return DEFAULT_SEND_TEXT_RETRY_BACKOFF
    try:
        return max(1.0, float(raw))
    except ValueError:
        return DEFAULT_SEND_TEXT_RETRY_BACKOFF


def _send_text_retry_jitter_sec() -> float:
    raw = (os.getenv("TELEGRAM_SEND_RETRY_JITTER_SEC", "") or "").strip()
    if not raw:
        return DEFAULT_SEND_TEXT_RETRY_JITTER_SEC
    try:
        return max(0.0, float(raw))
    except ValueError:
        return DEFAULT_SEND_TEXT_RETRY_JITTER_SEC


def _send_dedupe_window_sec() -> float:
    raw = (os.getenv("TELEGRAM_SEND_DEDUPE_WINDOW_SEC", "") or "").strip()
    if not raw:
        return DEFAULT_SEND_DEDUPE_WINDOW_SEC
    try:
        return max(1.0, float(raw))
    except ValueError:
        return DEFAULT_SEND_DEDUPE_WINDOW_SEC


def _cleanup_recent_send_keys(now_epoch: float, window_sec: float) -> None:
    stale_keys: list[str] = []
    for key, ts in _RECENT_SEND_KEYS.items():
        if (now_epoch - ts) > window_sec:
            stale_keys.append(key)
    for key in stale_keys:
        _RECENT_SEND_KEYS.pop(key, None)


def _safe_dedupe_fragment(value: str) -> str:
    normalized = re.sub(r"\s+", " ", str(value or "").strip())
    if not normalized:
        return "-"
    return normalized[:80]


def _get_http_session() -> requests.Session:
    global _HTTP_SESSION
    if _HTTP_SESSION is None:
        _HTTP_SESSION = requests.Session()
        _HTTP_SESSION.headers.update({"Connection": "keep-alive"})
    return _HTTP_SESSION


def _parse_allowed_users(value: Any) -> list[int]:
    if value is None:
        return []
    if isinstance(value, int):
        return [value]
    if isinstance(value, str):
        parts = [p.strip() for p in re.split(r"[,\s]+", value) if p.strip()]
        out: list[int] = []
        for p in parts:
            if p.isdigit():
                out.append(int(p))
        return sorted(set(out))
    if isinstance(value, (list, tuple, set)):
        out = []
        for item in value:
            s = str(item).strip()
            if s.isdigit():
                out.append(int(s))
        return sorted(set(out))
    return []


def _format_message_timestamp(raw_date: Any) -> str:
    if isinstance(raw_date, (int, float)):
        return datetime.fromtimestamp(raw_date).strftime("%Y-%m-%d %H:%M:%S")
    if isinstance(raw_date, str):
        parsed = _parse_timestamp(raw_date)
        if parsed:
            return parsed.strftime("%Y-%m-%d %H:%M:%S")
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def _parse_timestamp(value: Any) -> datetime | None:
    if isinstance(value, datetime):
        return value
    if isinstance(value, (int, float)):
        return datetime.fromtimestamp(value)
    if isinstance(value, str):
        for fmt in ("%Y-%m-%d %H:%M:%S", "%Y-%m-%dT%H:%M:%S"):
            try:
                return datetime.strptime(value, fmt)
            except ValueError:
                continue
    return None


def _safe_filename(name: str) -> str:
    base = os.path.basename(name).strip().replace("\x00", "")
    base = base.replace("/", "_").replace("\\", "_")
    return base or "file.bin"


def _make_default_filename(file_type: str, message_id: int, remote_path: str) -> str:
    ext = Path(remote_path).suffix or ".bin"
    prefix = {
        "photo": "image",
        "document": "document",
        "video": "video",
        "audio": "audio",
        "voice": "voice",
    }.get(file_type, "file")
    return f"{prefix}_{message_id}{ext}"


def _write_log_direct(logs_dir: Path, direction: str, event: str, details: dict[str, Any]) -> None:
    """Write log without runtime dict (used during initialization)."""
    try:
        logs_dir.mkdir(parents=True, exist_ok=True)
        _ensure_private_dir(logs_dir)

        log_path = logs_dir / f"{datetime.now().strftime('%Y-%m-%d')}.log"
        record = {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "direction": direction,
            "event": event,
            "details": details,
        }
        record = _redact_sensitive_payload(record)
        with log_path.open("a", encoding="utf-8") as f:
            f.write(json.dumps(record, ensure_ascii=False) + "\n")
        _ensure_private_file(log_path)
    except Exception:
        pass


def _write_log(runtime: dict[str, Any], direction: str, event: str, details: dict[str, Any]) -> None:
    logs_dir = Path(runtime["logs_dir"])
    logs_dir.mkdir(parents=True, exist_ok=True)
    _ensure_private_dir(logs_dir)
    _cleanup_old_logs(logs_dir)

    log_path = logs_dir / f"{datetime.now().strftime('%Y-%m-%d')}.log"
    record = {
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "direction": direction,
        "event": event,
        "details": details,
    }
    record = _redact_sensitive_payload(record)
    with log_path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(record, ensure_ascii=False) + "\n")
    _ensure_private_file(log_path)


def _collect_network_diagnostics() -> dict[str, Any]:
    nameservers: list[str] = []
    resolv_path = Path("/etc/resolv.conf")
    try:
        if resolv_path.exists():
            for line in resolv_path.read_text(encoding="utf-8", errors="replace").splitlines():
                s = line.strip()
                if not s or s.startswith("#"):
                    continue
                if s.lower().startswith("nameserver "):
                    parts = s.split()
                    if len(parts) >= 2:
                        nameservers.append(parts[1])
                if len(nameservers) >= 3:
                    break
    except Exception:
        pass

    dns_ok = False
    dns_error = ""
    dns_addresses: list[str] = []
    try:
        infos = socket.getaddrinfo("api.telegram.org", 443, proto=socket.IPPROTO_TCP)
        dns_addresses = sorted({entry[4][0] for entry in infos if entry and len(entry) >= 5 and entry[4]})
        dns_ok = bool(dns_addresses)
    except Exception as exc:
        dns_error = f"{type(exc).__name__}: {exc}"

    proxy_keys = ("HTTP_PROXY", "HTTPS_PROXY", "ALL_PROXY", "NO_PROXY")
    proxy_present = {k: bool(os.getenv(k)) for k in proxy_keys}

    diag: dict[str, Any] = {
        "user": os.getenv("USER", ""),
        "uid": os.getuid() if hasattr(os, "getuid") else "",
        "home": os.getenv("HOME", ""),
        "python": sys.version.split()[0],
        "requests": getattr(requests, "__version__", ""),
        "resolv_nameservers": nameservers,
        "dns_lookup_ok": dns_ok,
        "dns_lookup_addresses": dns_addresses[:8],
        "proxy_env_present": proxy_present,
    }
    if dns_error:
        diag["dns_lookup_error"] = dns_error
    return diag


def _cleanup_old_logs(logs_dir: Path) -> None:
    cutoff_date = datetime.now().date() - timedelta(days=LOG_RETENTION_DAYS - 1)
    for log_file in logs_dir.glob("*.log"):
        try:
            log_date = datetime.strptime(log_file.stem, "%Y-%m-%d").date()
        except ValueError:
            continue
        if log_date < cutoff_date:
            try:
                log_file.unlink()
            except OSError:
                pass


def _prune_message_store_data(data: dict[str, Any], retention_days: int) -> int:
    """Prune old messages from store while preserving last_update_id."""
    messages = data.get("messages", [])
    if not isinstance(messages, list) or not messages:
        return 0

    cutoff = datetime.now() - timedelta(days=max(1, retention_days))
    kept: list[dict[str, Any]] = []
    removed = 0

    for msg in messages:
        if not isinstance(msg, dict):
            kept.append(msg)
            continue

        ts = _parse_timestamp(msg.get("timestamp"))
        if ts is None or ts >= cutoff:
            kept.append(msg)
            continue

        removed += 1

    if removed:
        data["messages"] = kept
    return removed


def _ensure_private_dir(path: Path) -> None:
    try:
        path.chmod(SECURE_DIR_MODE)
    except OSError:
        pass


def _ensure_private_file(path: Path) -> None:
    try:
        path.chmod(SECURE_FILE_MODE)
    except OSError:
        pass


def _redact_sensitive_payload(value: Any, parent_key: str | None = None) -> Any:
    key_sensitive = bool(parent_key and _SENSITIVE_KEY_RE.search(parent_key))
    if isinstance(value, dict):
        out: dict[str, Any] = {}
        for key, item in value.items():
            key_text = str(key)
            if _SENSITIVE_KEY_RE.search(key_text):
                out[key_text] = _redact_explicit_secret_value(item)
            else:
                out[key_text] = _redact_sensitive_payload(item, parent_key=key_text)
        return out

    if isinstance(value, list):
        return [_redact_sensitive_payload(item, parent_key=parent_key) for item in value]

    if isinstance(value, tuple):
        return [_redact_sensitive_payload(item, parent_key=parent_key) for item in value]

    if isinstance(value, str):
        return _redact_sensitive_text(value, force=key_sensitive)

    if key_sensitive and value is not None:
        return REDACTED_VALUE

    return value


def _redact_explicit_secret_value(value: Any) -> Any:
    if value is None:
        return None
    if isinstance(value, str):
        stripped = value.strip()
        if not stripped:
            return value
        return REDACTED_VALUE
    return REDACTED_VALUE


def _redact_sensitive_text(text: str, force: bool = False) -> str:
    if force and text.strip():
        return REDACTED_VALUE

    redacted = _SENSITIVE_ASSIGNMENT_RE.sub(_replace_assignment_secret, text)
    redacted = _SENSITIVE_QUERY_PARAM_RE.sub(
        lambda m: f"{m.group(1)}{REDACTED_VALUE}",
        redacted,
    )
    redacted = _AUTH_BEARER_RE.sub(lambda m: f"{m.group(1)}{REDACTED_VALUE}", redacted)

    for pattern in (
        _TELEGRAM_BOT_TOKEN_RE,
        _OPENAI_KEY_RE,
        _GITHUB_TOKEN_RE,
        _AWS_ACCESS_KEY_RE,
        _SLACK_TOKEN_RE,
    ):
        redacted = pattern.sub(REDACTED_VALUE, redacted)
    return redacted


def _replace_assignment_secret(match: re.Match[str]) -> str:
    prefix = match.group(1)
    raw_value = match.group(2)
    if len(raw_value) >= 2 and raw_value[0] == raw_value[-1] and raw_value[0] in {"'", '"'}:
        quote = raw_value[0]
        return f"{prefix}{quote}{REDACTED_VALUE}{quote}"
    return f"{prefix}{REDACTED_VALUE}"
